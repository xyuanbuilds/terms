[✅] 易懂、易用
[*] 重点

动态规划
  最值类：只需要确保「不漏」即可，因为重复不影响结果。大概率双循环。
  求方案数类：需要确保「不重不漏」。重复可以尝试用 set 规避。
  路径问题：特征：方向移动，求路径数；注意边界、注意已走路径
    带障碍：障碍位置为 0 
    三角路径：自底向上（左底部）
  背包问题：
    0-1背包：可选物只可选一次；压缩时，背包 限重 从最大往小遍历，dp维度为限重 w
      `dp[w] = dp[w] || dp[w - cur]`
    完全背包：可选物可重复选；压缩时，背包 限重 从最小往大遍历，dp维度为限重 w
      `dp[w] = Math.min(dp[w] || Number.MAX_SAFE_INTEGER, dp[w - cur] + 1)`
  网格
   岛屿：寻找起始点+movesDFS（多源DFS）
      岛屿距离：寻找起始点+movesBFS（多源BFS）
        需要不与前选择冲突（记录访问过的内容）：回溯（标记已选择，或已访问）
  股票买卖：与上一天交易有关，二维，dp[日期][空仓 / 持有]
      res = Math.max(res, min !== price ? price - min : 0);
      含冷冻期: dp[日期][空仓 / 持有 / 冻结]
          `dp[i][0] = Math.max(pre[0], pre[2]);` // 空仓 继续空仓 或 pre冻结只能继续空仓
		      `dp[i][1] = Math.max(pre[1], pre[0] - price);` // 持有 pre持有 或 pre空仓刚买入
		      `dp[i][2] = pre[1] + price;` // 冻结 pre持有 + 刚卖出
  最长公共子序列
      `i 1, j 1`
      `text1[i - 1] === text2[j - 1];`
        // *  当前 i、j 相等，必定是一个公共串中的一位，取i、j都不取当前位的值 + 1
        ? `dp[i][j] = dp[i - 1][j - 1] + 1;`
        // * 不等，则分别舍去当前位的结果进行比较，也就是 j 或 i 只有一位可能影响结果
        : `dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);`
  最长连续子序列
      nums.sort((a, b) => a - b)
      if (nums[i] - nums[i - 1] === 1) {
        dp[i] = dp[i - 1] + 1;
      } else if (nums[i] === nums[i - 1]) {
        dp[i] = dp[i - 1];
      } else {
        dp[i] = 1;
      }

回溯：排列，非连续组合，子集
   `function backTrack(tmp: number[]) {
      if (tmp.length === nums.length) {
        res.push([...tmp]);
        return;
      }
      for (let num of nums) {
        if (tmp.find((i) => i === num) !== undefined) continue;
        tmp.push(num); // * 先入
        backTrack(tmp);
        tmp.pop(); // * 再出
      }
    }`
  全排列

如果要求连续的啥，一定不是回溯

BFS
  借助队列
  计算从树的最左侧开始，

DFS
  借助堆栈、或直接使用递归
  中序：左 -> 父 -> 右

头尾双指针：
  for i, left = i, right = lens - 1 - i
  盛雨水：
  盛最多水的容器：谁矮谁走
  两数之和 II - 输入有序数组

双指针
  删除有序数组中的重复项：

快慢指针：关键词 环！
  链表类问题
  数字可类比指针指

滑动窗口：关键词 连续！
  连续序列问题
  替换后的最长重复字符：滑动窗口，窗口只做递增，charCodeAt 记录最大值
  无重复子串：窗口右移，出现重复 l 右移，并去除不需要的内容
  合并区间：先排序，在遍历合并

区间类问题：1. 排序，确定边界型问题，重点关注哪一个边界更为重要
  箭射气球：也是边界问题的一种，所以先排序，排序右边界

链表：
很多链表类问题都涉及翻转链表；
同时很多问题都可以用快慢指针遍历后再操作来实现；
由于链表的限制，可以借助栈来做翻转；
  重排链表：快慢指针，获得中心点，偶数会获得中心右侧，之后翻转右侧，再插入
  旋转链表：获得旋转需要的行进步数
    const done = k % len;
    let steps = Math.abs((done === 0 ? len : done) - len);
  回文链表：
    1. 后序遍历回溯期比对比较容易
    2. 快慢指针翻转中心点后续再比对
  排序链表 *（归并排序掌握不够）
    归并排序
  相交链表
    分别对两个链表遍历，遍历A推入Set，遍历B时查看是否存在重复，第一个重复即为相交
    单纯双指针，存在交叉，在走完一条时走另一条，有交叉，两个指针会同时指在交叉点上，或最终走完都是null
  K 个一组翻转链表 * （较为困难）
  合并K个升序链表
    全放进一个数组排序，然后重造
  环形链表
    所有环形链表，一律快慢指针

队列

优先队列（堆）

二分查找：关键词 有序！查找！
   ! const mid = (l + r) >> 1; // 计算后值靠左，取到左，用于取左边界，l = mid + 1;
   ! const mid = (l + r + 1) >> 1; // 计算后值靠右，取到右，用于取右边界，r = mid - 1;
   ! 逐步 缩小搜索区间，l 及 r 的变化要有效，l / r 存在遍历后不变的情况，就会死循环
   const mid = (l + r) >> 1; // mid 值靠左（floor）， l 一定要 + 1
   if (nums[mid] < target) {
      l = mid + 1;
   } else {
      r = mid - 1;
   }

   return nums[r] === target ? r : -1

回文
  最长回文子串：中心扩散法
  回文链表：快慢指针，fast & false.next 完成遍历后，slow 表示中心位置，slow.next 后续翻转链表，翻转完后再比对
      * fast 不为 null，slow 要多走一位
  回文子串：动态规划，从尾部开始遍历

前缀和：关键词 子数组，其实很像滑动窗口（只是通过记住前缀，只需要一个指针进行遍历）
用于解决 连续子数组类 问题，从前往后遍历
因为 连续子数组和 实际就是 当前数组和 - 前缀和
  和为 K 的子数组
  长度最小的子数组

单调堆：用于解决下一个更大xx类问题，从后往前遍历
  下一个更大元素 I

二叉树
  前序遍历：边遍历边计算
    翻转二叉树： [node.right, node.left] = [DFS(node.left), DFS(node.right)];
  中序遍历：从 左或右 往 右或左 计算
    二搜索叉树转化为累加树
  后序遍历：从下往上计算
    二叉树直径
    平衡二叉树
    打家劫舍三（获取递归结果后进行计算，也算后序）


排序
  拓扑排序
  快速排序

括号类问题：栈，存左括号，遇到右括号出栈

由于链表的特性，可以先入栈，再出栈，实现尾部开始的遍历

重点例题：
  回文、nSum、滑动窗口、分治、前缀和
  接雨水、楼层遮挡、岛屿、背包、爬楼梯两种实现

动态规划
  爬楼梯、打家劫舍、不同路径、最小路径和、零钱兑换、买卖股票

tips:
  Object 会对 key 自动排序