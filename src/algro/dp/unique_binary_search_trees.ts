/**
 * 动态规划关键词：二叉搜索树
 * unique-binary-search-trees
 */

/**
 * 排列/组合：决策的顺序对结果有没有影响，则为组合
 * 顺序无关，所以属于组合
 * 排列几乎就意味着 阶乘，也就是需要穷举
 * 而组合一般意味着能够找到子问题，可以动态规划
 */

/**
 * 给定一个有序序列 `1⋯n`
 * 子问题：
 *  1. 以 1 为树根，二叉搜索树的可能集合
 *  2. 以 2 为树根，二叉搜索树的可能集合 ...
 *
 * 遍历每个数字 i，将该数字作为树根
 * 根据二叉搜索树性质， `1⋯(i-1)` 序列必然作为左子树，而 `(i+1)⋯n` 序列必然作为右子树。
 *
 * 子树的集合中可能性与顺序无关，只与元素个数有关。
 *
 * 所以对于 root 为 i的 结果，可以通过 左右两个 集合获得
 * 对于 i 为 root 的集合 = 左集合 * 右集合（相当于左右各取一种可能，求笛卡尔积）
 * 而对于 n 问题的 结果则为 1...n做root 的结果 累加求和
 *
 * 子树的可能性，与子树包含的项数有关，与顺序无关。
 */
function numTrees(n: number): number {
  const dp = new Array(n + 1).fill(0); // 包含 0 位，所以 n + 1

  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i += 1) {
    // 从 1 -> n，0、1 为 base 以计算获得
    for (let root = 1; root <= i; root += 1) {
      // 选择 1 -> n 作为跟节点
      dp[i] += dp[root - 1] * dp[i - root]; // dp[i] 为 1...n 所有root可能的和，所以需要 +=
      // root - 1 -> [1, ...(i-1)] 的个数
      // i - root -> [(i+1), ...n] 的个数
    }
  }

  return dp[n];
}
