# 排序

排序后，可双指针逼近目标

排序后，重复元素可循环末尾跳过（无需哈希记录）

# 缓存

元素已遍历后，可缓存位置（或是否存在），后续需要，可直接获取（减少重复遍历获取过程）。

判断重复元素，可使用 set 缓存。

# 双指针

链表存在交叉（环），大多可采用双指针交汇

头尾双指针，可用于目标逼近

# 常用

(i % 2) === 0：偶数（even）
奇数（odd）
 
# 常见错误

交换计算，须先用临时变量存放先被赋值的一方；或直接使用数组解构辅助计算（[a, b] = [b, a]）；

递归参数，递归过程中少传；

在递归过程中需要增减的数值类型，需要放入递归参数中，同时将该数值放入引用类型中，通过引用类型修改数值，例如：岛屿大小的计数

区间开/闭，其中 slice 左闭右开；

判等时，注意是值判等，还是饮用判等；

++ 的滞后性与 +=1 的即时性；

Array 模拟 队列，需要 shift 出队，push 入队；
Array 模拟 堆栈，需要 pop 出队，push 入队；

# 通用联想

不需要额外空间：双指针、位运算

连续的空间线性查找：二分法（确立边界）

常规时间优化：备忘录

常规空间优化：双指针；

数组类删除优化：避免前部/中间删除，可替换到尾部（将需要的替换到前部）删除

对称结构（回文）优化：从中间向两边；

对于无法快速反应的问题，大概率如下处理：有符合场景的数据结构，优秀用数据结构，之后考虑分治、贪心、DP 等固有解法，实在不行先循环穷举或递归。

能够列出公式，确认无后效性，确认递推方向，即能够 DP；

无顺序插入（不重复），要获得顺序排列，使用优先队列

## DP

DP 中的递推性，可能来自从左往右，也可能来自从右往左；

DP 表维度，由可变状态数决定；
而可变状态为计算子问题的必要数据，这个数据可能会直接得到（如：arr[index]、index），也可能需要整理得到，但每个子问题的这个状态，都是独立不重复的；

树状结构的 DP，一维，且该维度为 当前节点，变量为 当前节点是否选择/出现。另外

## 模式
1．滑动窗口
2．二指针或迭代器
3．快速和慢速指针或迭代器
4．合并区间
5．循环排序
6．原地反转链表
7．树的宽度优先搜索（Tree BFS）
8．树的深度优先搜索（Tree DFS）
9．Two Heaps
10．子集
11．经过修改的二叉搜索
12．前 K 个元素
13．K 路合并
14．拓扑排序
15. 回溯
